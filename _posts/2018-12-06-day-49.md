---
title: "[Day 49] Regular Expression"
date: 2018-12-06 11:00:00 +0900
tags:
  - FDS
  - Etc
comments: true
---

# 정규표현식

**문자의 패턴을 표현하는 언어**

## 정규 표현식 만들기

1. 정규식 리터럴

   ```js
   // 생성자 방식에 비해 성능상 더 좋다!
   // 컴파일이 한번만 된다.
   const re1 = /abc+/
   ```

2. RegExp 생성자

   ```js
   // 컴파일이 여러번 된다.
   // 정규식을 동적으로 생성해야할 때에만 쓴다. (서버로 받은 데이터로부터 정규식을 생성하거나 할 때...)
   const re2 = new RegExp('abc+')
   ```

## 정규 표현식 사용하기

[MDN - 정규식 사용하기](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/%EC%A0%95%EA%B7%9C%EC%8B%9D#%EC%A0%95%EA%B7%9C%EC%8B%9D_%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0)

문자열 래퍼 객체(String)의 `match`, `search`, `split`, `replace` 메소드가 정규식을 입력받아서 사용할 수 있다.

```js
// Example
"Hi, do you know your abc's?".match(/abc/);
// indexOf('string')과 유사하지만 정규표현식을 지원한다는 장점이 있다.
"Hi, do you know your abc's?".search(/abc/);	
"Hi, do you know your abc's?".split(/abc/);
"Hi, do you know your abc's?".replace(/abc/, 'ABC');
// * 는 앞에 있는 b가 없거나, 한 번 이상 등장하는 패턴(b가 0회 이상 등장하는 패턴)
"1234 abbbbbc 1234".match(/ab*c/);
// match는 정규식 패턴과 일치하는 것을 찾으면 배열을 리턴, 못찾으면 null 리턴
"1234 abbbbbc 1234".search(/ab*c/);
"1234 abbbbbc 1234".split(/ab*c/);
"1234 abbbbbc 1234".replace(/ab*c/, '{$&}');
```

## 정규 표현식 객체의 메소드

```js
// re3는 정규 표현식 객체이다.
const re3 = /ab*c/
// exec 메소드는 String의 match 메소드와 비슷하다.
re3.exec("1234 abbbbbc 1234");
// 패턴이 있는지를 검사해서 있으면 true, 없으면 false 리턴
re3.test("1234 abbbbbc 1234");
```

## 특수문자 사용하기

일부 특수문자들은 정규표현식 안에서 사용되었을 때 **특별한 의미를 갖는다.**

1. 특수문자 앞에 위치한 백슬래시(`\`) : 특수 문자의 의미를 없앤다.

   특수문자가 아닌 문자 앞에 위치한 백슬래시는 특별한 기능을 갖는다.

2. `^` : 입력의 시작 부분에 대응된다.

3. `$` : 입력의 끝 부분과 대응된다.

4. `*` : 앞의 표현식이 **0회 이상** 반복되는 부분과 대응된다.

5. `+` : 앞의 표현식이 **1회 이상** 반복되는 부분과 대응된다.

6. `?` : 앞의 표현식이 **0 또는 1회** 등장하는 부분과 대응된다. (나오거나 안나오거나)

   `?` 를 수량자(`*`, `+`) 바로 뒤에 사용하면 가능한 적게 대응시키도록 만든다.

7. `.` : 개행 문자를 제외한 모든 단일 문자와 대응된다. (숫자, 특수문자 포함)

   즉, `.`은 하나의 문자로 인정받는다.

8. `(x)` : 포획 괄호 ---> 부분 표현식 'x' 를 하나의 단위로 취급한다. 그리고 그것을 **기억한다.**

9. `(?:x)` : 비포획괄호 ---> 포획 괄호에서 **기억하는 기능이 빠진다.**

10. `x|y` : 'x' 또는 'y'에 대응된다.

11. `{n}` : 앞 표현식이 정확히 n번(n은 양수) 나타나는 부분에 대응된다. (수량자)

12. `{n, m}` : n <= m 을 만족할 때, 앞 문자가 최소 n개 최대 m개 나타나는 부분에 대응된다.

13. `[xyz]` : 문자셋. ---> 괄호 안의 어떤 문자(이스케이프 시퀀스 `\` 포함)와도 대응된다. 

    `.` 이나 `*` 같은 특수문자들은 문자셋 안에서 특별한 의미가 없는 단순 문자로 작동한다.

    `-` 은 문자의 범위를 지정해주는 특별한 의미를 갖는다.

14. `[^xyz]` : 부정 문자셋. ---> 괄호 내부에 등장하지 않는 어떤 문자와도 대응된다.

15. `\b` : 다른 단어 문자가 앞이나 뒤에 등장하지 않는 위치인 단어 경계에 대응된다. 

    공백과도 일치하고, 문자열의 처음과 끝과도 일치한다.

16. `\d` : 숫자 문자에 대응된다. ---> [0-9] 와 같은 의미. (d는 digit의 약자)

17. `\n` : 줄 바꿈 문자에 대응된다. (line-feed)

18. `\r` : 캐리지 리턴 문자에 대응 된다. (carriage-return)

19. `\s` : 스페이스, 탭, 폼 피드, 줄 바꿈 문자 등을 포함한 하나의 공백 문자에 대응된다.

20. `\w` : 밑줄 문자를 포함한 영 숫자 문자에 대응된다. ---> [A-Za-Z0-9_]와 동일하다.

## 플래그를 이용한 고급 검색

1. `g` - 전역 검색
2. `i` - 대소문자 구분 없는 검색
3. `m` - 다중행(multi-line) 검색
4. `u` - 유니코드. ---> 패턴을 유니코드 코드 포인트의 나열로 취급한다.